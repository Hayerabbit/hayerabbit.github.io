---
layout:     post
title:      "设计模式概要"
subtitle:   " 简介与八大原则"
date:       2020-07-16 17:35:00
author:     "Hayer"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 旧存档
    - CS
---


## 设计模式简介

> 三大面向对象机制：
>
> 封装：隐藏内部实现
>
> 继承：复用现有代码
>
> 多态：改写代码行为

**可复用**是面向对象设计模式的目标，而**变化**是软件设计复杂的根本原因。

而如何解决复杂性？

一种选择是分治（面向过程），但分治并不适合复用。

二是抽象（面向对象），采取一种通用方法统一处理。

变化是复用的天敌，面向对象设计最大优势在于**抵御变化**。



## 面向对象设计模式原则

### 重新认识面向对象

①理解隔离变化，从宏观层面，面向对象的构建方式更能适应软件的变化。

②各司其责。从微观层面，面向对象更强调各个类的”责任“。由于需求变化导致的新增类型不应该影响其他原有类的实现。（多态）

### 面向对象设计原则

#### 依赖导致原则（DIP）

- 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
- 抽象（稳定）不应该依赖于实现细节（变化），而应该反过来。

> Eg：在MainForm里实现Line类的Draw和Rect类的Draw。
>
> 解法一：在MainForm里实例化Line类和Rect类对象然后调用它们的Draw。 (错误，高层模块不应该依赖于低层模块)
>
> 解法二：构建一个抽象类Shape类，Draw虚函数化，然后Line类和Rect类继承Shape类并实现Draw方法，将MainForm类依赖于Shape类。（对,不论高层模块还是低层模块都应该依赖抽象)

上述例子实现了”隔离变化“，即将Line类和Rect类这个层级发生变化时，高层模块和抽象模块却能尽可能的保持稳定。例如，采用解法二，再加个Circle类，不会对上层造成多大变化。而如果是解法一，由于MainForm类依赖于低层模块，导致MainForm也变得不稳定，就需要连同低层一起变化。



#### 开放封闭原则（OCP）

- 对扩展开放，对更改封闭。
- 类模块应该是可扩展的，但是不可修改。

> 这一点在上个例子的讲解中，也有所体现，再添加Circle类时，不应去修改原有的类，而应该新建一个Circle类继承自Shape类然后实现自己的Draw方法。



#### 单一职责原则（SRP）

- 一个类应该**仅有一个**引起它变化的原因。
- 变化的方向隐含着类的责任。

> 一个类不应该承担太多责任，否则容易变成超级类。



#### Liskov替换原则（LSP）

- 子类必须能够替换它们的基类。
- 继承表达类型抽象。

> 翻译一下就是：
>
> ①子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
>
> ②当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
>
> ③当子类的方法实现父类的**抽象**方法时，方法的后置条件（即方法的返回值）要比父类更严格。

②和③最好的例子就是HashMap和Map。当父类方法参数为HashMap时，子类实现该方法时形参可为Map，而倒过来就不合适。当父类方法返回为HashMap时，子类在实现该方法时不应该返回Map（编译器也会报错）。

假如我非要不遵循里氏替换原则会有什么后果？ 后果就是：**你写的代码出问题的几率将会大大增加。**



#### 接口隔离原则（ISP)

- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。

> 类似单一职责原则。

~~*热知识：接口在C++中为抽象类。*~~



#### 合成复用原则

- 优先使用对象组合，而不是继承来达到复用的目的。

继承在某种程度上破坏了封装性，子类父类耦合性高。而对象组合只要求被组合的对象有良好定义的外部接口，耦合度低。

> 这个我个人感觉有点难懂。这里举个详细的例子：(Java版)
>
> 比如，有一个人从春熙路到天府广场去。可以怎么实现呢？

```Java
class Man{
public void run(){
System.out.println("前往天府广场");
}
}
class CDMan extends Man{
}
……
CDMan c = new CDMan();
c.run();
```

> 当我们调用run()方法时，就只能打印从父类中继承的run方法。如果这个人想骑单车去天府广场应该怎么办呢？有人说，简单，在CDMan中重写run()不就行了吗？

```java
class CDMan extends Man{
@Override
public void run(){
System.out.println("骑单车去天府广场");
}
}
```

那如果这个人想骑单车走一段，再开汽车走一段，就没法通过继承和重写来实现了。继承是一种静态的复用，不能在运行时发生改变，灵活性比较差。

那要怎么解决呢？改变思路，用用”has-a”(有什么或用什么)去替代”is-a”(是什么)。

```Java
class Plane{
public void fly(){}
}
class Ship{
public void swim(){}
}
class ManKind {
private Plane p = new Plane();
private Ship s = new Ship();
public void fly(){
p.fly();
}
public void swim(){
s.swim();
}
}
```

> 从以上代码可以看出，通过聚合/组合关系，可以解决继承的缺点。由于一个类可以建多个属性，也就是可以聚合多个类。所以，可以通过聚合/组合关系，重用多个类中的代码。
>
> 聚合/组合复用也可以在运行时动态进行。新对象可以使用聚合/组合关系，将新的责任委派到合适的对象。

```Java
//交通工具接口
interface Vehicle{
	public  void run();
}
//自行车实现类
class Bike implements Vehicle{
	public void run(){
		System.out.println("骑单车行走");
	}
}
//汽车实现类
class Car implements Vehicle{
	public void run(){
		System.out.println("开汽车行走");
	}
}
//人类
class CDMan {
	private Vehicle  v;
	public void run(){
		v.run();
	}
//更换交通工具
	public void changeVehicle(Vehicle  v){
		this.v = v;
	}
}
……
CDMan c = new CDMan();
c.changeVehicle(new Bike());
c.run();//骑单车行走
c.changeVehicle(new Car());
c.run();//开汽车行走
```

综上所述，继承存在的缺点为：①父类的方法子类无条件继承，很容易造成方法污染。（我理解为破坏封装性）②从父类中继承的方法，是一种静态的复用。不能在运行时发生改变，不够灵活。

使用继承需要谨慎。一般来说，使用继承有两个条件：①父类中所有的属性和方法，在子类中都适用。②子类不需要再去重用别的类中的代码。



#### 封装变化点

- 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良影响。（解耦）



#### 针对接口编程，而不是针对实现编程

- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现”高内聚，低耦合“。


> 第一个例子里的解法一，就也违背了这个原则。而解法二遵循了这个原则。

